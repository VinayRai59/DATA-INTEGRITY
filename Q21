#include <ixwebsocket/IXWebSocket.h>
#include <iostream>
#include <unistd.h>
#include <string>
#include <nlohmann/json.hpp>

using namespace std;
using json = nlohmann::json;

void trigger_rest_recovery(
    const string& reason,
    long long from_trade_id,
    long long to_trade_id
)
{
    cout << "[REST_RECOVERY] reason=" << reason
         << " | from=" << from_trade_id
         << " | to=" << to_trade_id
         << endl;

    // FUTURE:
    // - REST API call
    // - Backfill trades
    // - Replay into CandleBuilder
}

int main(){
    ix::WebSocket ws;

    bool has_last = false;
    long long last_id = -1;
    const long long OVERFLOW_LIMIT = 300;

    ws.setUrl("wss://stream.binance.com:9443/ws/btcusdt@trade");

    ws.setOnMessageCallback(
        [&](const ix::WebSocketMessagePtr& msg)
        {
            if(msg->type == ix::WebSocketMessageType::Open)
            {
                cout << "Websocket Connected Successfully" << endl;
                has_last = false;
                last_id = -1;
            }

            else if(msg->type == ix::WebSocketMessageType::Close ||
                    msg->type == ix::WebSocketMessageType::Error)
            {
                cout << "[NETWORK] WebSocket disconnected" << endl;

                trigger_rest_recovery(
                    "NETWORK_DISCONNECT",
                    last_id,
                    -1
                );

                has_last = false;
                last_id = -1;
            }

            else if(msg->type == ix::WebSocketMessageType::Message)
            {
                try
                {
                    json j = json::parse(msg->str);

                    if(j.contains("result") && j.contains("id"))
                        return;

                    if(j.contains("e") && j["e"] == "trade")
                    {
                        long long trade_id = j["t"].get<long long>();

                        if(!has_last)
                        {
                            has_last = true;
                            last_id = trade_id;
                            return;
                        }

                        if(trade_id == last_id)
                        {
                            cout << "[DUPLICATE] " << trade_id << endl;
                            return;
                        }

                        if(trade_id < last_id)
                        {
                            long long diff = last_id - trade_id;

                            if(diff > OVERFLOW_LIMIT)
                            {
                                cout << "[OVERFLOW] reset detected. last="
                                     << last_id << " new=" << trade_id << endl;

                                trigger_rest_recovery(
                                    "TRADE_ID_OVERFLOW",
                                    trade_id,
                                    -1
                                );

                                last_id = trade_id;
                            }
                            else
                            {
                                cout << "[OUT_OF_ORDER] trade_id="
                                     << trade_id << endl;
                            }
                            return;
                        }

                        if(trade_id > last_id + 1)
                        {
                            long long from_id = last_id + 1;
                            long long to_id   = trade_id - 1;

                            cout << "[LOSS] missing="
                                 << (to_id - from_id + 1) << endl;

                            trigger_rest_recovery(
                                "TICK_LOSS",
                                from_id,
                                to_id
                            );

                            last_id = trade_id;
                            return;
                        }

                        cout << "[NORMAL] " << trade_id << endl;
                        last_id = trade_id;
                    }
                }
                catch(const exception& e)
                {
                    cout << "Error: " << e.what() << endl;
                }
            }
        }
    );

    ws.start();

    while(true)
        usleep(500);

    ws.stop();
    return 0;
}
